import speech_recognition as sr
import glob
import sys
from math import isnan
import pandas as pd
import auditok
import matplotlib

# Windows
#matplotlib.use('Agg')
# Linux
matplotlib.use('tkagg')


'''
This script receives a log file produced by PsychoPy.
The log regards a naming task, including one word for each recording (although it has been partially
tested with two words per recording, namely a verb and an object). 
It requires to have the word properly written for comparison with the speech recognition engine.
It is written for use with Greek language, using the model created by Fotis Pantazoglou
(Pantazoglou, Fotios & Papadakis, Nikolaos & Kladis, Georgios. (2017). Implementation of the generic Greek Model for CMU Sphinx speech recognition toolkit.)
The model is found on https://sourceforge.net/projects/cmusphinx/files/Acoustic%20and%20Language%20Models/Greek/ . In order to use it,
uncompress to <path>/speech_recognition/pocketsphinx-data/el-gr and rename the files in accordance with the filenames in en-US folder.

It searches for the respective word in the audio recording, finds a match (0-1), time regions, response latency (if it exists) and saves the paths of graphs
for each audio region identified. 

The output is a csv file, similar to the input, with the following columns added: word found, match (0,1), speech time regions, response latency

'''


def process(fname, wordlist):
    '''
    The basic recognition function. Uses key-word matching, searching for one (or 2 maybe) particular words.

    Input:
    ------
    fname (string): The full path of the recording holding the word for identification
    wordlist (string): The respective word read from the PsychoPy log

    Output:
    -------
    res (string): The word if it matches the one generated by the model

    '''
    r = sr.Recognizer()
    with sr.AudioFile(fname) as src:
        audio = r.record(src)

    try:
        res = r.recognize_sphinx(audio, language='el-gr', 
                keyword_entries=wordlist, show_all=False)

        # For debugging:
        # print(res)

        return res 

    except sr.UnknownValueError:
        print("Sphinx could not understand audio")
    except sr.RequestError as e:
        print("Sphinx error; {0}".format(e))
    return '-1'

def find_regions(fname, min_dur=.2, max_dur=2, max_silence=.3, energy_threshold=55, analysis_window=.01,
                drop_trailing_silence=True):
    '''
    Uses empirical values to calculate regions of when the participant started speaking and when he/she finished.

    Input:
    ------
    fname (string): full path to .wav recording

    Output:
    -------
    result (list of 3 element tuples): 0 - region id, 1 - region start, 2 - region end
    *.jpg (image): saves an image with the region identified in the same folder with the .wav recording
    picName (string): the name of the image (same as fname with .jpg extension)
    '''

    kwargs = {
              'min_dur':min_dur,
              'max_dur':max_dur,
              'max_silence':max_silence,
              'energy_threshold':energy_threshold,
              'analysis_window':analysis_window,
              'drop_trailing_silence':drop_trailing_silence
              }
                    
    audio_regions = auditok.split(fname, **kwargs)

    result = [(i, r.meta.start, r.meta.end) for i, r in enumerate(audio_regions)]

    


    # Plot
    region = auditok.load(fname)
    picName = fname.rstrip('.wav') + '.jpg' # Change '.wav' if another format is used
    regions = region.splitp(show=False, save_as=picName,**kwargs)
    # Prints a RuntimeWarning: More than ... figures have been opened
    # Haven't found a way to bypass it
    plt.close('all')
    del regions

    return result, picName



def unstress_word(word):
    '''
    Receives a word (in greek) and returns a wordlist
    with the possible combinations of its characters stressed-unstressed.
    E.g. 'αϊτή' (haiti) -> ['αϊτή', 'αιτή', 'αϊτη', 'αιτη']
    The need for this function comes up from the greek dictionary of pocketsphinx
    <name here>, which has some unstressed words.
    
    ***Not used actually, but still I kept it for educational purposes***
    
    Input: word (string)
    ------

    Output: wordlist (list of strings)
    -------
    '''

    stress_dict = {'ά':'α', 
                   'έ':'ε', 
                   'ή':'η', 
                   'ί':'ι',
                   'ύ':'υ',
                   'ό':'ο',
                   'ώ':'ω',
                   'ϋ':'υ',
                   'ϊ':'ι', 
                   'ΐ':'ι', 
                   'ΰ':'υ'}
    indices = []
    keys = stress_dict.keys()
    cntr = 0
    for letter in word:
        if letter in keys:
            indices.append(cntr)
        cntr += 1
    
    wordlist = [word]

    # if len(indices) == 0: 
    # No stressed word provided
    # Possible problems if word in dictionary is stressed???
    # Not tested


    # If anybody finds a greek word with more than 2 stressed characters
    # (symbols ϊ ί) and you're really sure about it, please let me know :P
    if len(indices) == 1:
        key = word[indices[0]]
        new_word = word.replace(key, stress_dict[key])
        wordlist.append(new_word)

    elif len(indices) == 2:
        for i in range(len(indices)):
            key = word[indices[i]]
            new_word = word.replace(key, stress_dict[key])
            wordlist.append(new_word)
        
        # Finally replace the first stressed character of the second word
        key = word[indices[0]]
        new_word = wordlist[-1].replace(key, stress_dict[key])
        wordlist.append(new_word)

    return wordlist
            
def main():

    results_file = sys.argv[1]
    #test_file = fpath+'yourlog.csv'
    try:
        df = pd.read_csv(results_file)
    except FileNotFoundError as e:
        print(e ,"\nCheck the file argument specified after the program name.")
        exit(1)

    try:
        wav_files = df['resp.filename']     # resp is the microphone component used in my experiment, change accordingly
        words = df['corrName']              # corrName pretty much the same, the word in greek to be identified
        #sound_word_pairs = zip(wordlist)
    except KeyError as e:
        print(e, '\nCheck the column in your .csv file \
              referring to microphone responses and/or the correct name')
        exit(1)

    # remove last empty column. I kept it for reference of what info is added
    #df = df.dropna(axis=1, how='all') 
    
    if len(words) != len(wav_files):
        print("Shape mishmatch, exiting")
        # TODO

        exit(1)

    words_matched = []
    matched = []
    regions = []
    picNames = []
    responseLatencies = []
    for i in range(len(words)):

        # Dealing with NaNs
        if type(words[i])==float and type(wav_files[i])==float:

            words_matched.append(float('nan'))
            matched.append(float('nan'))
            picNames.append(float('nan'))
            regions.append(float('nan'))
            responseLatencies.append(float('nan'))
            continue

        elif (type(words[i])==float) ^ (type(wav_files[i])==float):
            # Something gone wrong, file or corrName not logged
            # Exiting
            exit(1)

        # wordlist = unstress_word(words[i]) - Don't use it, it matches a list of stressed-unstressed word
        wordlist = words[i]
        wav_file = wav_files[i] 
        wl = (wordlist,1.0) 
        # Documentation at https://github.com/Uberi/speech_recognition/blob/master/speech_recognition/__init__.py states that 1.0 is the most sensitive,
        # (more false positives) and 0.0 the least sensitive (more false negatives). In testing it has been found that the inverse holds. To be tested
        # furthermore and possibly submitted as a correction?

        word_found = process(wav_file, [wl])
        words_matched.append(word_found.rstrip(' ').lstrip(' '))

        # For debugging:
        # print(word_found+'\n'+wordlist)

        if (word_found in wordlist) or (wordlist in word_found):
            matched.append(True)
        else:
            matched.append(False)
        print('Word Found:', word_found, 'Word Searched:', wordlist)

        region, picName = find_regions(wav_file)
        regions.append(region)

        # If only one region found, keep it's start as response latency, else investigate further the new log
        if len(region) == 1: # Form of [(i, start, end)]
            responseLatencies.append(region[0][1])
        else:
            responseLatencies.append(-1)
        picNames.append(picName)

    
    df['Words_found'] = words_matched
    df['Response_latencies'] = responseLatencies
    df['Matched'] = matched
    print(regions)
    df['Speech_regions'] = regions
    df['Waveform_graph'] = picNames

    

    # Append a simple _2 to new file, change as desired
    df.to_csv(sys.argv[1].split('.')[0] + '_2.csv')

if __name__=='__main__':
    main()
